files:
  - path: ./htmlrepo.py
    content: |
      #!/usr/bin/env python3
      
      import os
      import sys
      import json
      from pathlib import Path
      
      def parse_config_file(config_file):
          extensions = []
          exclude_extensions = []
          ignore_folders = []
      
          with open(config_file, 'r') as file:
              for line in file:
                  line = line.strip()
                  if not line or line.startswith('#'):
                      continue
                  
                  if line.startswith('!'):
                      exclude_extensions.append(line[1:])
                  elif line.startswith('/'):
                      ignore_folders.append(line[1:])
                  else:
                      extensions.append(line)
      
          return extensions, exclude_extensions, ignore_folders
      
      def format_yaml_like(files_data):
          output = "files:\n"
          for file_data in files_data:
              output += f"  - path: {file_data['path']}\n"
              output += "    content: |\n"
              content_lines = file_data['content'].splitlines()
              for line in content_lines:
                  output += f"      {line}\n"
          return output
      
      def format_json(files_data):
          return json.dumps({'files': files_data}, indent=2)
      
      def format_html(files_data):
          output = "<html><body><pre>\n"
          for file_data in files_data:
              output += f"<h2>{file_data['path']}</h2>\n"
              output += "<code>\n"
              output += file_data['content']
              output += "</code>\n<br/>\n"
          output += "</pre></body></html>"
          return output
      
      def format_xml(files_data):
          output = "<files>\n"
          for file_data in files_data:
              output += f"  <file>\n"
              output += f"    <path>{file_data['path']}</path>\n"
              output += "    <content><![CDATA[\n"
              output += file_data['content']
              output += "\n    ]]></content>\n"
              output += "  </file>\n"
          output += "</files>"
          return output
      
      def collect_code_files(root_dir, output_file, extensions, exclude_extensions, ignore_dirs, output_format):
          files_data = []
          
          for dirpath, dirnames, filenames in os.walk(root_dir):
              # Skip ignored directories
              dirnames[:] = [d for d in dirnames if os.path.join(dirpath, d) not in ignore_dirs]
              
              for filename in filenames:
                  file_ext = os.path.splitext(filename)[1]
                  if file_ext in exclude_extensions or filename == output_file:
                      continue
                  if not extensions or file_ext in extensions:
                      file_path = os.path.join(dirpath, filename)
                      with open(file_path, 'r') as code_file:
                          content = code_file.read()
                      files_data.append({
                          'path': file_path,
                          'content': content
                      })
          
          if output_format == 'yaml':
              formatted_output = format_yaml_like(files_data)
          elif output_format == 'json':
              formatted_output = format_json(files_data)
          elif output_format == 'xml':
              formatted_output = format_xml(files_data)
          else:  # Default to HTML
              formatted_output = format_html(files_data)
      
          if output_file == '-':
              print(formatted_output)
          else:
              with open(output_file, 'w') as file:
                  file.write(formatted_output)
      
      if __name__ == "__main__":
          import argparse
      
          # Default extensions for most common programming languages
          default_extensions = [
              '.js', '.ts', '.py', '.jsx', '.tsx', '.html', '.css', '.cpp', '.java', 
              '.c', '.cs', '.rb', '.php', '.go', '.rs', '.swift', '.json',
              '.xml', '.yml', '.yaml', '.sh', '.bash', '.ps1', '.bat', '.cmd',
              '.sql', '.pl', '.perl', '.r', '.lua', '.m', '.mm', '.h', '.hpp',
              '.hxx', '.cxx', '.cshtml', '.aspx', '.jsp', '.asp', '.ejs', '.md',
              '.markdown', '.rst', '.txt', '.conf', '.cfg', '.ini', '.env', '.envrc',
              'Dockerfile', 'Makefile', 'Rakefile', 'Gemfile', 'Vagrantfile', 'Procfile',
          ]
      
          parser = argparse.ArgumentParser(description="Collect code files into a structured format.")
          parser.add_argument('start_directory', help="The directory to start searching from.")
          parser.add_argument('-o', '--output', default='report.yaml', help="The output file name. Use '-' for stdout.")
          parser.add_argument('-f', '--format', choices=['yaml', 'json', 'xml', 'html'], default='yaml', help="The output format: yaml, json, xml, or html.")
          parser.add_argument('-e', '--extensions', nargs='*', help="List of file extensions to include.")
          parser.add_argument('-x', '--exclude-extensions', nargs='*', help="List of file extensions to exclude.")
          parser.add_argument('-i', '--ignore-folders', nargs='*', help="List of directories to ignore.")
          parser.add_argument('-c', '--config', default=os.path.expanduser('~/.htmlrepoignore'), help="Path to a config file for default settings.")
      
          args = parser.parse_args()
      
          # Initialize with defaults
          extensions = args.extensions if args.extensions else default_extensions
          exclude_extensions = args.exclude_extensions if args.exclude_extensions else []
          ignore_folders = args.ignore_folders if args.ignore_folders else []
      
          # Load settings from config file if it exists
          if os.path.exists(args.config):
              config_extensions, config_exclude_extensions, config_ignore_folders = parse_config_file(args.config)
              extensions = config_extensions or extensions
              exclude_extensions = config_exclude_extensions or exclude_extensions
              ignore_folders = config_ignore_folders or ignore_folders
      
          # Resolve full paths for ignored directories
          ignore_dirs = [os.path.abspath(os.path.join(args.start_directory, d)) for d in ignore_folders]
          
          collect_code_files(args.start_directory, args.output, extensions, exclude_extensions, ignore_dirs, args.format)
  - path: ./test_htmlrepo.py
    content: |
      import os
      import tempfile
      import unittest
      from htmlrepo import collect_code_files
      
      class TestHTMLRepo(unittest.TestCase):
          
          def setUp(self):
              # Create a temporary directory
              self.test_dir = tempfile.TemporaryDirectory()
              self.test_file_paths = []
              
              # Create some test files
              self.test_file_paths.append(self._create_file("test1.py", "print('Hello World')"))
              self.test_file_paths.append(self._create_file("test2.js", "console.log('Hello World')"))
              self.test_file_paths.append(self._create_file("test3.html", "<h1>Hello World</h1>"))
              
              # Create a temporary config file
              self.temp_config_file = tempfile.NamedTemporaryFile(delete=False)
          
          def tearDown(self):
              # Cleanup the temporary directory and config file
              self.test_dir.cleanup()
              os.unlink(self.temp_config_file.name)
          
          def _create_file(self, filename, content):
              file_path = os.path.join(self.test_dir.name, filename)
              with open(file_path, 'w') as f:
                  f.write(content)
              return file_path
      
          def test_yaml_output(self):
              output_file = os.path.join(self.test_dir.name, "output.yaml")
              collect_code_files(self.test_dir.name, output_file, [], [], [], 'yaml')
              
              with open(output_file, 'r') as f:
                  output = f.read()
              
              self.assertIn("files:", output)
              self.assertIn("path: " + self.test_file_paths[0], output)
              self.assertIn("print('Hello World')", output)
      
          def test_json_output(self):
              output_file = os.path.join(self.test_dir.name, "output.json")
              collect_code_files(self.test_dir.name, output_file, [], [], [], 'json')
              
              with open(output_file, 'r') as f:
                  output = f.read()
              
              self.assertIn('"files": [', output)
              self.assertIn('"path": "' + self.test_file_paths[0], output)
              self.assertIn('"print(\'Hello World\')"', output)
      
          def test_xml_output(self):
              output_file = os.path.join(self.test_dir.name, "output.xml")
              collect_code_files(self.test_dir.name, output_file, [], [], [], 'xml')
              
              with open(output_file, 'r') as f:
                  output = f.read()
              
              self.assertIn("<files>", output)
              self.assertIn("<path>" + self.test_file_paths[0] + "</path>", output)
              self.assertIn("<![CDATA[\nprint('Hello World')\n", output)
      
          def test_html_output(self):
              output_file = os.path.join(self.test_dir.name, "output.html")
              collect_code_files(self.test_dir.name, output_file, [], [], [], 'html')
              
              with open(output_file, 'r') as f:
                  output = f.read()
              
              self.assertIn("<html><body><pre>", output)
              self.assertIn(f"<code>\nprint('Hello World')</code>", output)
      
          def test_exclude_extensions(self):
              output_file = os.path.join(self.test_dir.name, "output.yaml")
              collect_code_files(self.test_dir.name, output_file, [], ['.py'], [], 'yaml')
              
              with open(output_file, 'r') as f:
                  output = f.read()
              
              self.assertNotIn("print('Hello World')", output)
              self.assertIn("console.log('Hello World')", output)
      
          def test_ignore_folders(self):
              # Create a subdirectory and a file inside it
              sub_dir = os.path.join(self.test_dir.name, "subdir")
              os.makedirs(sub_dir)
              sub_file_path = self._create_file("subdir/test4.py", "print('This should be ignored')")
              
              output_file = os.path.join(self.test_dir.name, "output.yaml")
              collect_code_files(self.test_dir.name, output_file, [], [], [sub_dir], 'yaml')
              
              with open(output_file, 'r') as f:
                  output = f.read()
              
              self.assertNotIn("print('This should be ignored')", output)
      
          def test_default_config(self):
              # Write to the temporary config file
              with open(self.temp_config_file.name, 'w') as f:
                  f.write("!*.js\n")
              
              output_file = os.path.join(self.test_dir.name, "output.yaml")
              
              # Call collect_code_files with the temporary config file
              collect_code_files(
                  root_dir=self.test_dir.name, 
                  output_file=output_file, 
                  extensions=[], 
                  exclude_extensions=[], 
                  ignore_dirs=[], 
                  output_format='yaml', 
                  config=self.temp_config_file.name  # Modify your function to accept this or apply it inside the test
              )
              
              with open(output_file, 'r') as f:
                  output = f.read()
              
              self.assertNotIn("console.log('Hello World')", output)
      
      
      if __name__ == '__main__':
          unittest.main()
  - path: ./README.md
    content: |
      ### HTMLRepo - Collect Code Files into an HTML File
      
      This Python script, `htmlrepo`, recursively finds code files in a specified 
      directory and compiles their contents into an HTML file. 
      
      The script is highly configurable, allowing users to specify file extensions, 
      exclude certain extensions, ignore directories, and use a configuration file for default settings.
      
      #### Features
      
      - Recursively find code files: Collect files with specified extensions from a directory and its subdirectories.
      - HTML output: The contents of the found files are compiled into a single HTML file for easy viewing.
      - Customizable extensions: Define which file extensions to include or exclude.
      - Ignore directories: Specify directories to ignore during the search.
      - Configuration file: Set default options in a config file following a .gitignore-like format.
      
      #### Installation
      
      1. Create a file named htmlrepo in a directory of your choice `touch htmlrepo`
      2. Copy the script content into the htmlrepo file.
      3. Make the script executable: `chmod +x htmlrepo`
      4. (Optional) Move the script to a directory in your PATH (e.g., /usr/local/bin) `sudo mv htmlrepo /usr/local/bin/`
      5. Verify the installation `htmlrepo --help`
      
      #### Usage
      
      Basic Usage
      
          htmlrepo .
      
      This will search for code files in the current directory using most common programming language file extensions
      and output an HTML file named `htmlreport.html` in the current directory.
      
      #### Options
      
      - `-o, --output` : Specify the output HTML file name.
          htmlrepo . -o output.html
      
      - `-e, --extensions` : List the file extensions to include.
          htmlrepo . -e .py .js .jsx
      
      - `-x, --exclude-extensions` : List the file extensions to exclude.
          htmlrepo . -x .css .html
      
      - `-i, --ignore-folders` : List the directories to ignore.
          htmlrepo . -i node_modules dist
      
      - `-c, --config` : Specify a custom config file. Defaults to `~/.htmlrepoignore`.
          htmlrepo . -c /path/to/custom_config.txt
      
      #### Configuration File
      
      The script can use a configuration file to set default options, allowing you to avoid specifying the same options repeatedly.
      
      Default config file location: `~/.htmlrepoignore`
      
      Custom config file: Specify with the `-c` option.
      
      Config file format (similar to .gitignore):
      
      - Extensions to include: List the file extensions directly.
      - Extensions to exclude: Prefix with `!`.
      - Directories to ignore: Prefix with `/`.
      
      Example config file (`~/.htmlrepoignore`):
      
          # Extensions to include
          .py
          .js
          .jsx
      
          # Extensions to exclude
          !.css
      
          # Folders to ignore
          /node_modules
          /dist
      
      Example Command
      
          htmlrepo . -o output.html -e .py .js -x .html -i node_modules dist
      
      This command will search for `.py` and `.js` files, exclude `.html` files, 
      ignore the `node_modules` and `dist` directories, and generate an `output.html` 
      file in the current directory.
      
      License
      
      This project is licensed under the MIT License. See the LICENSE file for details.
